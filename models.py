from flask_sqlalchemy import SQLAlchemy
from flask_login import UserMixin
import datetime
from sqlalchemy.orm import relationship
from werkzeug.security import generate_password_hash, check_password_hash

db = SQLAlchemy()

class User(UserMixin, db.Model):
    __tablename__ = 'users'  # Explicit table name

    id = db.Column(db.Integer, primary_key=True)
    full_name = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False, index=True)
    password_hash = db.Column(db.String(256)) # Increased length for potentially stronger hashes
    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow)
    is_deleted = db.Column(db.Boolean, default=False, nullable=False, index=True)
    deleted_at = db.Column(db.DateTime, nullable=True)

    # Relationships
    pdf_documents = relationship("PDFDocument", back_populates="user", cascade="all, delete-orphan") # Cascade will be handled by soft delete logic
    chat_messages = relationship("ChatMessage", back_populates="user", cascade="all, delete-orphan") # This might change if ChatMessage links to ChatSession
    chat_sessions = relationship("ChatSession", back_populates="user", cascade="all, delete-orphan")
    contracts = relationship("Contract", back_populates="user", cascade="all, delete-orphan")
    dilekceler = relationship("Dilekce", back_populates="user", cascade="all, delete-orphan")
    ifadeler = relationship("Ifade", back_populates="user", cascade="all, delete-orphan") # Added for Ifade model


    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        if self.password_hash is None: # Handle cases where password_hash might be None
            return False
        return check_password_hash(self.password_hash, password)

    def __repr__(self):
        return f"<User {self.email}>"

class PDFDocument(db.Model):
    __tablename__ = 'pdf_documents'

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False, index=True)
    filename = db.Column(db.String(255), nullable=False)
    original_filename = db.Column(db.String(255), nullable=False) # To store the user's original file name
    file_hash = db.Column(db.String(64), nullable=False, index=True) # SHA-256 hash
    filepath = db.Column(db.String(512), nullable=False) # Path where the file is stored on the server
    upload_date = db.Column(db.DateTime, default=datetime.datetime.utcnow, index=True)
    processed = db.Column(db.Boolean, default=False, nullable=False) # To track if the PDF has been processed by Langchain
    vector_db_collection_name = db.Column(db.String(100)) # Name of the ChromaDB collection for this PDF
    is_deleted = db.Column(db.Boolean, default=False, nullable=False, index=True) # For soft delete of metadata
    deleted_at = db.Column(db.DateTime, nullable=True)


    # Relationships
    user = relationship("User", back_populates="pdf_documents")
    chat_messages = relationship("ChatMessage", back_populates="pdf_document") # Removed cascade, will be handled by ChatSession
    chat_sessions = relationship("ChatSession", back_populates="pdf_document", cascade="all, delete-orphan")


    def __repr__(self):
        return f"<PDFDocument {self.filename} (User: {self.user_id})>"

class ChatSession(db.Model):
    __tablename__ = 'chat_sessions'
    id = db.Column(db.Integer, primary_key=True)
    session_uuid = db.Column(db.String(36), unique=True, nullable=False, index=True) # For the UUID
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False, index=True)
    pdf_document_id = db.Column(db.Integer, db.ForeignKey('pdf_documents.id'), nullable=False, index=True)
    title = db.Column(db.String(255), nullable=True) # Generated by Groq
    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow, index=True)
    updated_at = db.Column(db.DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow, index=True) # Last message time
    is_deleted = db.Column(db.Boolean, default=False, nullable=False, index=True)
    deleted_at = db.Column(db.DateTime, nullable=True)

    user = relationship("User", back_populates="chat_sessions")
    pdf_document = relationship("PDFDocument", back_populates="chat_sessions")
    messages = relationship("ChatMessage", back_populates="chat_session", cascade="all, delete-orphan", order_by="ChatMessage.timestamp")

    def __repr__(self):
        return f"<ChatSession {self.session_uuid} (User: {self.user_id}, PDF: {self.pdf_document_id}, Title: {self.title})>"


class ChatMessage(db.Model):
    __tablename__ = 'chat_messages'

    id = db.Column(db.Integer, primary_key=True)
    chat_session_id = db.Column(db.Integer, db.ForeignKey('chat_sessions.id'), nullable=False, index=True)
    # user_id and pdf_document_id can be inferred from chat_session if needed, but keeping for direct query simplicity for now
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False, index=True) 
    pdf_document_id = db.Column(db.Integer, db.ForeignKey('pdf_documents.id'), nullable=True, index=True)

    sender_type = db.Column(db.String(10), nullable=False)  # 'user' or 'ai'
    message_content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.datetime.utcnow, index=True)
    is_deleted = db.Column(db.Boolean, default=False, nullable=False, index=True)
    deleted_at = db.Column(db.DateTime, nullable=True)

    # Relationships
    chat_session = relationship("ChatSession", back_populates="messages")
    user = relationship("User", back_populates="chat_messages") # Direct link to user who sent message
    pdf_document = relationship("PDFDocument", back_populates="chat_messages") # Direct link to PDF (denormalized but can be useful)


    def __repr__(self):
        return f"<ChatMessage {self.id} (Session: {self.chat_session_id}, Sender: {self.sender_type})>"


class Contract(db.Model):
    __tablename__ = 'contracts'

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False, index=True)
    contract_type = db.Column(db.String(100), nullable=False) # e.g., 'is_sozlesmesi', 'kira_sozlesmesi'
    title = db.Column(db.String(255), nullable=True) # User-defined or auto-generated title
    input_data = db.Column(db.JSON, nullable=True) # Stores the form inputs for the contract
    generated_content_html = db.Column(db.Text, nullable=True) # The AI-generated contract text in HTML
    generated_content_text = db.Column(db.Text, nullable=True) # Plain text version, if needed
    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow, index=True)
    updated_at = db.Column(db.DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)
    is_deleted = db.Column(db.Boolean, default=False, nullable=False, index=True)
    deleted_at = db.Column(db.DateTime, nullable=True)

    # Relationships
    user = relationship("User", back_populates="contracts")

    def __repr__(self):
        return f"<Contract {self.id} (Type: {self.contract_type}, User: {self.user_id})>"


class Dilekce(db.Model):
    __tablename__ = 'dilekceler' # Using 'dilekceler' as table name

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False, index=True)
    dilekce_type = db.Column(db.String(100), nullable=False) # e.g., 'dava_dilekcesi', 'itiraz_dilekcesi'
    title = db.Column(db.String(255), nullable=True) # User-defined or auto-generated title
    input_data = db.Column(db.JSON, nullable=True) # Stores the form inputs for the dilekce
    generated_content_html = db.Column(db.Text, nullable=True) # The AI-generated dilekce text in HTML
    generated_content_text = db.Column(db.Text, nullable=True) # Plain text version, if needed
    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow, index=True)
    updated_at = db.Column(db.DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)
    is_deleted = db.Column(db.Boolean, default=False, nullable=False, index=True)
    deleted_at = db.Column(db.DateTime, nullable=True)

    # Relationships
    user = relationship("User", back_populates="dilekceler")

    def __repr__(self):
        return f"<Dilekce {self.id} (Type: {self.dilekce_type}, User: {self.user_id})>"


class Ifade(db.Model):
    __tablename__ = 'ifadeler' # Using 'ifadeler' as table name

    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False, index=True)
    ifade_type = db.Column(db.String(100), nullable=False) # e.g., 'supheli_ifadesi', 'tanik_ifadesi'
    title = db.Column(db.String(255), nullable=True) # User-defined or auto-generated title
    input_data = db.Column(db.JSON, nullable=True) # Stores the form inputs for the ifade
    generated_content_html = db.Column(db.Text, nullable=True) # The AI-generated ifade text in HTML
    generated_content_text = db.Column(db.Text, nullable=True) # Plain text version, if needed
    created_at = db.Column(db.DateTime, default=datetime.datetime.utcnow, index=True)
    updated_at = db.Column(db.DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)
    is_deleted = db.Column(db.Boolean, default=False, nullable=False, index=True)
    deleted_at = db.Column(db.DateTime, nullable=True)

    # Relationships
    user = relationship("User", back_populates="ifadeler")

    def __repr__(self):
        return f"<Ifade {self.id} (Type: {self.ifade_type}, User: {self.user_id})>"


def init_app(app):
    """Initializes the database with the Flask app."""
    db.init_app(app)

    with app.app_context():
        # Import models here to ensure they are registered with SQLAlchemy
        # before create_all is called.
        # from . import models # This line can cause circular import if not careful
        db.create_all()
        print("Database tables created or already exist.")
